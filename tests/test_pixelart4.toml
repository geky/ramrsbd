# This test is just for generating the pixel art in the readme
#

code = '''
#include "ramrsbd.h"

// here is a 4-bit version of our pixel art, where each nibble is 2 pixels
static const uint8_t PIXELART[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x33, 0x33, 0x33, 0x33, 0x33, 0x31, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x33, 0x11, 0x11, 0x33, 0x31, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x31, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x33, 0x20, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x31, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x33, 0x33, 0x33, 0x33, 0x30, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x30, 0x00, 0x01, 0x11, 0x03, 0x30, 0x32, 0x33, 0x33, 0x33, 0x20, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x32, 0x20, 0x11, 0x02, 0x33, 0x30, 0x20, 0x00, 0x00, 0x22, 0x20, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x03, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x22, 0x11, 0x33, 0x33, 0x30, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x03, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x22, 0x01, 0x13, 0x33, 0x33, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x03, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x22, 0x01, 0x13, 0x33, 0x33, 0x22, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x13, 0x03, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x32, 0x22, 0x01, 0x13, 0x33, 0x33, 0x22, 0x01, 0x13, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x11, 0x33, 0x32, 0x00, 0x33, 0x33, 0x33, 0x33, 0x32, 0x20, 0x11, 0x33, 0x33, 0x33, 0x22, 0x01, 0x13, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x03, 0x33, 0x20, 0x00, 0x00, 0x23, 0x33, 0x22, 0x01, 0x11, 0x33, 0x33, 0x33, 0x22, 0x11, 0x13, 0x33, 0x33, 0x33, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x33, 0x20, 0x00, 0x00, 0x00, 0x00, 0x11, 0x13, 0x33, 0x33, 0x32, 0x20, 0x11, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x11, 0x13, 0x33, 0x33, 0x33, 0x22, 0x01, 0x13, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x23, 0x33, 0x33, 0x33, 0x32, 0x22, 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x32, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x33, 0x33, 0x33, 0x33, 0x33, 0x32, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

// a function for printing 4-bit pixel art, note 0-3 map to .':
static void printpixelart(
        const uint8_t *pixelart,
        lfs_size_t width,
        lfs_size_t height) {
    for (lfs_size_t y = 0; y < height; y++) {
        for (lfs_size_t x = 0; x < 2*width; x++) {
            uint8_t c = 0xf & (pixelart[y*width + x/2] >> 4*(2-1-(x%2)));
            printf("%c", " .\x27:456789abcdef"[c]);
        }
        printf("\n");
    }
}
'''

# width/height of 4-bit pixel art
defines.WIDTH = 32
defines.HEIGHT = 16

defines.CODE_SIZE = 'WIDTH + ECC_SIZE'
defines.ECC_SIZE = 16
defines.ERASE_SIZE = 'CODE_SIZE * HEIGHT'

defines.READ_SIZE = 'CODE_SIZE - ECC_SIZE'
defines.PROG_SIZE = 'CODE_SIZE - ECC_SIZE'
defines.BLOCK_SIZE = 'ERASE_SIZE - ((ERASE_SIZE/CODE_SIZE)*ECC_SIZE)'


[cases.test_pixelart4_bits]
defines.SEED = 42
code = '''
    ramrsbd_t ramrsbd;
    struct lfs_config cfg_ = *cfg;
    cfg_.context = &ramrsbd;
    cfg_.read  = ramrsbd_read;
    cfg_.prog  = ramrsbd_prog;
    cfg_.erase = ramrsbd_erase;
    cfg_.sync  = ramrsbd_sync;
    struct ramrsbd_config ramrsbdcfg = {
        .code_size = CODE_SIZE,
        .ecc_size = ECC_SIZE,
        .erase_size = ERASE_SIZE,
        .erase_count = ERASE_COUNT,
    };
    ramrsbd_create(&cfg_, &ramrsbdcfg) => 0;

    // write our pixel art
    cfg_.erase(&cfg_, 0) => 0;
    cfg_.prog(&cfg_, 0, 0, PIXELART, WIDTH*HEIGHT) => 0;

    // corrupt until we can no longer read
    uint32_t prng = SEED;
    lfs_size_t n = 0;
    while (true) {
        // choose a random bit
        lfs_size_t bit = TEST_PRNG(&prng) % (8*(WIDTH+ECC_SIZE)*HEIGHT);
        // flip
        ramrsbd.buffer[bit/8] ^= 1 << (bit%8);

        // can we read?
        uint8_t buffer[WIDTH*HEIGHT];
        int err = cfg_.read(&cfg_, 0, 0, buffer, WIDTH*HEIGHT);
        if (err) {
            // no? undo last bit error and terminate
            ramrsbd.buffer[bit/8] ^= 1 << (bit%8);
            break;
        }

        n += 1;
    }

    // print the corrupted contents on disk, including any ecc
    printf("corrupted:\n");
    printpixelart(ramrsbd.buffer, WIDTH + ECC_SIZE, HEIGHT);

    // repair by reading and rewriting
    uint8_t buffer[WIDTH*HEIGHT];
    cfg_.read(&cfg_, 0, 0, buffer, WIDTH*HEIGHT) => 0;
    cfg_.erase(&cfg_, 0) => 0;
    cfg_.prog(&cfg_, 0, 0, buffer, WIDTH*HEIGHT) => 0;

    // print the repaired contents on disk, including any ecc
    printf("repaired:\n");
    printpixelart(ramrsbd.buffer, WIDTH + ECC_SIZE, HEIGHT);

    ramrsbd_destroy(&cfg_) => 0;
'''

[cases.test_pixelart4_bytes]
defines.SEED = 42
code = '''
    ramrsbd_t ramrsbd;
    struct lfs_config cfg_ = *cfg;
    cfg_.context = &ramrsbd;
    cfg_.read  = ramrsbd_read;
    cfg_.prog  = ramrsbd_prog;
    cfg_.erase = ramrsbd_erase;
    cfg_.sync  = ramrsbd_sync;
    struct ramrsbd_config ramrsbdcfg = {
        .code_size = CODE_SIZE,
        .ecc_size = ECC_SIZE,
        .erase_size = ERASE_SIZE,
        .erase_count = ERASE_COUNT,
    };
    ramrsbd_create(&cfg_, &ramrsbdcfg) => 0;

    // write our pixel art
    cfg_.erase(&cfg_, 0) => 0;
    cfg_.prog(&cfg_, 0, 0, PIXELART, WIDTH*HEIGHT) => 0;

    // corrupt until we can no longer read
    uint32_t prng = SEED;
    lfs_size_t n = 0;
    while (true) {
        // choose a random byte
        lfs_size_t byte = TEST_PRNG(&prng) % ((WIDTH+ECC_SIZE)*HEIGHT);
        // flip
        ramrsbd.buffer[byte] ^= 0xff;

        // can we read?
        uint8_t buffer[WIDTH*HEIGHT];
        int err = cfg_.read(&cfg_, 0, 0, buffer, WIDTH*HEIGHT);
        if (err) {
            // no? undo last byte error and terminate
            ramrsbd.buffer[byte] ^= 0xff;
            break;
        }

        n += 1;
    }

    // print the corrupted contents on disk, including any ecc
    printf("corrupted:\n");
    printpixelart(ramrsbd.buffer, WIDTH + ECC_SIZE, HEIGHT);

    // repair by reading and rewriting
    uint8_t buffer[WIDTH*HEIGHT];
    cfg_.read(&cfg_, 0, 0, buffer, WIDTH*HEIGHT) => 0;
    cfg_.erase(&cfg_, 0) => 0;
    cfg_.prog(&cfg_, 0, 0, buffer, WIDTH*HEIGHT) => 0;

    // print the repaired contents on disk, including any ecc
    printf("repaired:\n");
    printpixelart(ramrsbd.buffer, WIDTH + ECC_SIZE, HEIGHT);

    ramrsbd_destroy(&cfg_) => 0;
'''
