# Test moving config things into ROM
#

code = '''
#include "ramrsbd.h"
'''

defines.CODE_SIZE = [16, 64, 128]
defines.ECC_SIZE = 32
defines.ERASE_SIZE = 4096
if = 'ECC_SIZE < CODE_SIZE'

defines.READ_SIZE = 'CODE_SIZE - ECC_SIZE'
defines.PROG_SIZE = 'CODE_SIZE - ECC_SIZE'
defines.BLOCK_SIZE = 'ERASE_SIZE - ((ERASE_SIZE/CODE_SIZE)*ECC_SIZE)'

# test storing the generator polynomial in ROM
[cases.test_rom_p]
code = '''
    // generated by: ./rs-poly.py 32
    const uint8_t P[32] = {
        0x74, 0x40, 0x34, 0xae, 0x36, 0x7e, 0x10, 0xc2,
        0xa2, 0x21, 0x21, 0x9d, 0xb0, 0xc5, 0xe1, 0x0c,
        0x3b, 0x37, 0xfd, 0xe4, 0x94, 0x2f, 0xb3, 0xb9,
        0x18, 0x8a, 0xfd, 0x14, 0x8e, 0x37, 0xac, 0x58,
    };

    ramrsbd_t ramrsbd;
    struct lfs_config cfg_ = *cfg;
    cfg_.context = &ramrsbd;
    cfg_.read  = ramrsbd_read;
    cfg_.prog  = ramrsbd_prog;
    cfg_.erase = ramrsbd_erase;
    cfg_.sync  = ramrsbd_sync;
    struct ramrsbd_config ramrsbdcfg = {
        .code_size = CODE_SIZE,
        .ecc_size = ECC_SIZE,
        .erase_size = ERASE_SIZE,
        .erase_count = ERASE_COUNT,
        .p = P,
    };
    ramrsbd_create(&cfg_, &ramrsbdcfg) => 0;

    uint8_t buffer[READ_SIZE];

    // write data
    cfg_.erase(&cfg_, 0) => 0;
    for (lfs_off_t i = 0; i < READ_SIZE; i++) {
        buffer[i] = 'a' + (i % 26);
    }
    cfg_.prog(&cfg_, 0, 0, buffer, READ_SIZE) => 0;

    // try flipping each bit
    for (lfs_off_t i = 0; i < 8*CODE_SIZE; i++) {
        ramrsbd.buffer[i/8] ^= 1 << (i%8);

        // read data
        cfg_.read(&cfg_, 0, 0, buffer, READ_SIZE) => 0;

        // error correction should repair the bit
        for (lfs_off_t i = 0; i < READ_SIZE; i++) {
            LFS_ASSERT(buffer[i] == 'a' + (i % 26));
        }

        // undo the bit flip
        ramrsbd.buffer[i/8] ^= 1 << (i%8);
    }

    ramrsbd_destroy(&cfg_) => 0;
'''
